# Time Auction 구현 워크플로우

## 사전 합의
- **통신 방식**: 모든 클라이언트-서버 상호작용은 WebSocket을 주 통신 채널로 사용한다. `Controller`는 Spring의 `@MessageMapping`을 통해 WebSocket 메시지를 처리하는 컴포넌트를 지칭한다.

---

## 1단계: 구조 개편 및 모델 수정 (Foundation)
*목표: 본격적인 로직 구현에 앞서, 코드의 가독성을 높이고 필요한 데이터 필드를 미리 정의한다.*

1.  **패키지 이름 변경**
    - `src/main/java/com/jhpark/time_auction/bid` -> `.../record`로 변경한다.

2.  **파일 이름 변경**
    - `BidService.java` -> `RecordService.java`
    - `BidController.java` -> `RecordController.java`
    - `BidRecord.java` -> `RoundRecord.java`
    - `BidBank.java` -> `TimeWallet.java`

3.  **클래스 내용 변경 (이름 및 임포트)**
    - 이름이 변경된 모든 파일의 클래스 선언부 (`public class ...`)와, 이 클래스를 사용하는 다른 파일의 `import` 구문을 모두 수정한다.

4.  **모델 필드 추가**
    - `RoomEntry.java`: 아래 필드를 추가한다.
      ```java
      private boolean isReady = false;
      private boolean isParticipating = false;
      ```
    - `TimeWallet.java`: 아래 필드를 추가한다.
      ```java
      private int roundWins = 0;
      ```

---

## 2단계: 핵심 로직 구현 (`RecordService`)
*목표: 게임의 핵심 메커니즘인 '시간 기록 및 계산' 기능을 독립적으로 완성한다.*

1.  **`RecordServiceImpl.java` 파일 생성 및 구현**
    - `RecordService` 인터페이스의 구현체를 만든다.
    - **`createTimeWallets` 메소드 구현**:
      - 게임 시작 시 호출되며, 참여한 유저 ID 목록을 받아 각 유저의 `TimeWallet`을 생성한다.
      - 초기 `timeLeft` (예: 300초)과 `roundWins = 0`으로 설정하여 Redis 등에 저장한다.
    - **`startRecord` 메소드 구현**:
      - `RoundRecord` 객체를 생성하고 `startTime`을 기록하여 저장한다.
    - **`endRecord` 메소드 구현**:
      - `startRecord`로 만들어진 `RoundRecord`를 찾아 `endTime`을 기록하고 `duration`을 계산한다.
      - 해당 유저의 `TimeWallet`을 찾아 `timeLeft`에서 `duration`만큼 차감한다.

---

## 3단계: 흐름 조립 (`GameService`)
*목표: `RecordService` 등 다른 서비스를 이용하여 전체 게임의 시작, 라운드 진행, 종료 흐름을 완성한다.*

1.  **`GameServiceImpl.java` 의존성 주입**
    - `RecordService`, `RoomService` 등을 생성자 주입 방식으로 추가한다.

2.  **`startGame` 메소드 구현**:
    - `RoomService`에서 현재 방의 '준비' 상태인 유저 목록을 가져온다.
    - `RecordService.createTimeWallets`를 호출하여 시간 지갑을 만들어준다.
    - `Game` 객체를 생성하고, `startRound()`를 호출한다.

3.  **`startRound` 메소드 구현**:
    - 새 `Round` 객체를 생성한다.
    - (구현) 3초 타이머를 동작시켜 플레이어들의 참여 여부를 받는다. (`RoomService.setParticipation` 활용)
    - (구현) 60초 메인 라운드 타이머를 시작한다. 타이머 종료 시 `endRound()`가 호출되도록 설정한다. (예: `ScheduledExecutorService`)

4.  **`endRound` 메소드 구현**:
    - `RecordService.getRoundResult`를 호출하여 현재 라운드의 모든 시간 기록을 가져온다.
    - 가장 `duration`이 긴 플레이어를 승자로 결정하고, 해당 플레이어의 `TimeWallet.roundWins`를 1 증가시킨다.
    - 마지막 라운드인지 확인하고, 맞으면 `endGame()`을, 아니면 `startRound()`를 호출한다.

5.  **`endGame` 메소드 구현**:
    - 모든 플레이어의 `TimeWallet` 정보를 취합한다.
    - `roundWins`가 가장 높은 사람을 최종 승자로 결정한다. (동점 시 `timeLeft`가 많은 사람)

---

## 4단계: 외부 연결 (WebSocket Controllers)
*목표: 클라이언트의 요청을 받아 위에서 구현한 서비스 로직들을 실행시키고, 그 결과를 브로드캐스팅한다.*

1.  **`RoomController.java` 구현**
    - `@MessageMapping("/room/ready")`: `roomService.setReady()` 호출.
    - `@MessageMapping("/room/participate")`: `roomService.setParticipation()` 호출.

2.  **`GameController.java` 구현**
    - `@MessageMapping("/game/start")`: `gameService.startGame()` 호출.

3.  **`RecordController.java` 구현**
    - `@MessageMapping("/record/start")`: `recordService.startRecord()` 호출.
    - `@MessageMapping("/record/end")`: `recordService.endRecord()` 호출.

4.  **결과 브로드캐스팅 구현**
    - 각 서비스(`GameService`, `RoomService` 등)의 주요 상태 변경 지점에서 `SimpMessagingTemplate`을 사용하여 관련자들에게 결과를 전송한다.
    - 예: `endRound` 후, 라운드 결과를 `/topic/room/{roomId}/roundResult` 와 같은 토픽으로 브로드캐스팅.
